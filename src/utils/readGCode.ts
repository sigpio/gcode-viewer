import { parseStringSync, type GCodeCommand, type ParseOptions } from 'gcode-parser';

export type ToolpathSegment = {
  readonly start: [number, number, number];
  readonly end: [number, number, number];
  readonly extruding: boolean;
  readonly feedRate: number | null;
};

export type GCodeLayer = {
  readonly index: number;
  readonly zHeight: number | null;
  readonly commands: string[];
  readonly segments: ToolpathSegment[];
};

export type Bounds3D = {
  readonly minX: number;
  readonly maxX: number;
  readonly minY: number;
  readonly maxY: number;
  readonly minZ: number;
  readonly maxZ: number;
};

export type ParsedGCode = {
  readonly layers: GCodeLayer[];
  readonly totalCommands: number;
  readonly estimatedHeight: number | null;
  readonly bounds: Bounds3D | null;
  readonly metadata: Record<string, string>;
};

type MutableLayer = {
  index: number;
  zHeight: number | null;
  commands: string[];
  segments: ToolpathSegment[];
};

const EPSILON = 0.0001;
const KNOWN_METADATA_PREFIXES = ['generated by'];

const createLayer = (index: number, zHeight: number | null = null): MutableLayer => ({
  index,
  zHeight,
  commands: [],
  segments: []
});

const cloneBounds = (bounds: Bounds3D | null): Bounds3D | null =>
  bounds
    ? {
        minX: bounds.minX,
        maxX: bounds.maxX,
        minY: bounds.minY,
        maxY: bounds.maxY,
        minZ: bounds.minZ,
        maxZ: bounds.maxZ
      }
    : null;

const extendBounds = (bounds: Bounds3D | null, point: [number, number, number]): Bounds3D => {
  const [x, y, z] = point;
  if (!bounds) {
    return {
      minX: x,
      maxX: x,
      minY: y,
      maxY: y,
      minZ: z,
      maxZ: z
    };
  }
  return {
    minX: Math.min(bounds.minX, x),
    maxX: Math.max(bounds.maxX, x),
    minY: Math.min(bounds.minY, y),
    maxY: Math.max(bounds.maxY, y),
    minZ: Math.min(bounds.minZ, z),
    maxZ: Math.max(bounds.maxZ, z)
  };
};

const extractLine = (command: GCodeCommand): string => {
  if (typeof command.line === 'string') {
    return command.line;
  }
  if (typeof command.source === 'string') {
    return command.source;
  }
  if (typeof command.raw === 'string') {
    return command.raw;
  }
  return '';
};

const findWord = (command: GCodeCommand, letter: string): number | undefined => {
  const uppercaseLetter = letter.toUpperCase();
  if (command.args && typeof command.args === 'object') {
    const candidate = (command.args as Record<string, unknown>)[uppercaseLetter];
    if (typeof candidate === 'number' && Number.isFinite(candidate)) {
      return candidate;
    }
  }
  if (Array.isArray(command.words)) {
    const match = command.words.find(
      (word) =>
        typeof word.letter === 'string' &&
        word.letter.toUpperCase() === uppercaseLetter &&
        typeof word.value === 'number'
    );
    if (match && Number.isFinite(match.value)) {
      return match.value;
    }
  }
  const line = extractLine(command);
  const pattern = new RegExp(`${uppercaseLetter}(-?\\d*\\.?\\d+)`, 'i');
  const result = line.match(pattern);
  return result ? Number.parseFloat(result[1]!) : undefined;
};

type ParseResult = {
  layers: MutableLayer[];
  bounds: Bounds3D | null;
  totalCommands: number;
  metadata: Record<string, string>;
};

const parseCommands = (commands: GCodeCommand[]): ParseResult => {
  let absolutePositioning = true;
  let absoluteExtrusion = true;

  let position: [number, number, number, number] = [0, 0, 0, 0]; // x, y, z, e

  const layers: MutableLayer[] = [];
  let currentLayer = createLayer(0, 0);
  let bounds: Bounds3D | null = null;
  let totalCommands = 0;
  const metadata: Record<string, string> = {};

  const pushLayer = () => {
    if (currentLayer.commands.length > 0 || currentLayer.segments.length > 0) {
      layers.push(currentLayer);
      currentLayer = createLayer(currentLayer.index + 1);
    }
  };

  for (const command of commands) {
    totalCommands += 1;
    const line = extractLine(command);
    let targetLayer = currentLayer;

    const rawCode = (command.cmd ?? command.code ?? line.split(/\s+/)[0] ?? '').toString();
    const code = rawCode.toUpperCase();

    const recordLine = () => {
      if (line) {
        targetLayer.commands.push(line);
      }
    };

    if (code === 'G90') {
      recordLine();
      absolutePositioning = true;
      continue;
    }
    if (code === 'G91') {
      recordLine();
      absolutePositioning = false;
      continue;
    }
    if (code === 'M82') {
      recordLine();
      absoluteExtrusion = true;
      continue;
    }
    if (code === 'M83') {
      recordLine();
      absoluteExtrusion = false;
      continue;
    }

    if (!code.startsWith('G')) {
      recordLine();
      if (line.startsWith(';')) {
        const content = line.replace(/^;\s*/, '');
        const colonIndex = content.indexOf(':');
        if (colonIndex >= 0) {
          const key = content.slice(0, colonIndex).trim().toLowerCase();
          const value = content.slice(colonIndex + 1).trim();
          if (key) {
            metadata[key] = value;
          }
          continue;
        }
        const lowerContent = content.toLowerCase();
        const prefix = KNOWN_METADATA_PREFIXES.find((candidate) =>
          lowerContent.startsWith(`${candidate} `)
        );
        if (prefix) {
          metadata[prefix] = content.slice(prefix.length).trim();
        }
      }
      continue;
    }

    const motionCode = code.replace('G', '');
    if (!['0', '00', '1', '01'].includes(motionCode)) {
      recordLine();
      continue;
    }

    const nextPosition: [number, number, number, number] = [...position];

    const xWord = findWord(command, 'X');
    const yWord = findWord(command, 'Y');
    const zWord = findWord(command, 'Z');
    const eWord = findWord(command, 'E');
    const fWord = findWord(command, 'F');

    if (typeof xWord === 'number') {
      nextPosition[0] = absolutePositioning ? xWord : position[0] + xWord;
    }
    if (typeof yWord === 'number') {
      nextPosition[1] = absolutePositioning ? yWord : position[1] + yWord;
    }
    if (typeof zWord === 'number') {
      const absoluteZ = absolutePositioning ? zWord : position[2] + zWord;
      if (
        currentLayer.zHeight !== null &&
        absoluteZ > (currentLayer.zHeight ?? 0) + EPSILON &&
        (currentLayer.commands.length > 0 || currentLayer.segments.length > 0)
      ) {
        pushLayer();
        targetLayer = currentLayer;
      }
      currentLayer.zHeight = absoluteZ;
      nextPosition[2] = absoluteZ;
    }
    if (typeof eWord === 'number') {
      nextPosition[3] = absoluteExtrusion ? eWord : position[3] + eWord;
    }

    recordLine();

    const hasMovement =
      Math.abs(nextPosition[0] - position[0]) > EPSILON ||
      Math.abs(nextPosition[1] - position[1]) > EPSILON ||
      Math.abs(nextPosition[2] - position[2]) > EPSILON;

    const deltaExtrusion = nextPosition[3] - position[3];
    const isExtruding = deltaExtrusion > EPSILON;

    if (hasMovement) {
      const segment: ToolpathSegment = {
        start: [position[0], position[1], position[2]],
        end: [nextPosition[0], nextPosition[1], nextPosition[2]],
        extruding: isExtruding,
        feedRate: typeof fWord === 'number' ? fWord : null
      };
      currentLayer.segments.push(segment);
      bounds = extendBounds(bounds, segment.start);
      bounds = extendBounds(bounds, segment.end);
    }

    position = nextPosition;
  }

  if (currentLayer.commands.length > 0 || currentLayer.segments.length > 0) {
    layers.push(currentLayer);
  }

  return { layers, bounds, totalCommands, metadata };
};

const safeParse = (source: string): GCodeCommand[] => {
  try {
    const parsed = parseStringSync(source, {
      flatten: false
    } satisfies ParseOptions);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Impossibile analizzare G-code con gcode-parser, fallback manuale', error);
    return [];
  }
};

/**
 * Effettua il parsing del file G-code utilizzando gcode-parser e costruisce i layer per il rendering.
 */
export const parseGCode = (source: string): ParsedGCode => {
  const commands = safeParse(source);
  const commandList =
    commands.length > 0
      ? commands
      : source.split(/\r?\n/).map((line) => ({ line }) as GCodeCommand);
  const { layers, bounds, totalCommands, metadata } = parseCommands(commandList);

  const estimatedHeight =
    layers.length > 0 ? layers[layers.length - 1]!.zHeight ?? null : bounds?.maxZ ?? null;

  return {
    layers: layers.map((layer) => ({
      index: layer.index,
      zHeight: layer.zHeight,
      commands: [...layer.commands],
      segments: [...layer.segments]
    })),
    totalCommands,
    estimatedHeight,
    bounds: cloneBounds(bounds),
    metadata
  };
};
